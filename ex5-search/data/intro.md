# Знакомство с Gameface

!!!tip "Что изучим"

    - Что такое Gameface и какие технологии он использует
    - Документация и код-стайл проекта
    - Особенности отрисовки
    - Как использовать ресурсы
    - Где смотреть ошибки

---

О том, что такое GF можно узнать [здесь](https://docs.coherent-labs.com/cpp-gameface/).

Нужно четко понимать, что GF это не web. GF работает на собственном движке, который может показаться в сравнении с современными браузерами очень ограниченным, но все ограничения направлены на увеличение производительности. JS работает на движке v8, его функциональность реализована практически полностью, исключением является работа с DOM и событиями GF движка. В работе с CSS и HTML так же есть нюансы. Поддержка свойств, событий, тегов описана в оф. документации и меняется из версии в версию, поэтому когда вы сверяетесь с поддержкой чего либо всегда нужно сверяться и с версией, которая находится в данный момент в клиенте игры. Здесь еще раз стоит напомнить, что движок молодой и самописный - могут быть баги в реализации или отхождение от общепринятых стандартов. Итак, документация:

-   [особенность GF верстки](https://docs.coherent-labs.com/cpp-gameface/what_is_gfp/htmlfeaturesupport/)
-   [поддержка HTML](https://docs.coherent-labs.com/cpp-gameface/content_development/supported_features_tables/htmlelements/)
-   [поддержка свойств CSS](https://docs.coherent-labs.com/cpp-gameface/content_development/supported_features_tables/cssproperties/)
-   [поддержка селекторов CSS](https://docs.coherent-labs.com/cpp-gameface/content_development/supported_features_tables/cssselectors/)
-   [поддержка JavaScript DOM Events](https://docs.coherent-labs.com/cpp-gameface/content_development/supported_features_tables/jsevents/)
-   [JavaScript DOM API](https://docs.coherent-labs.com/cpp-gameface/api_reference/modules/group___d_o_m___a_p_i/)

## Проектные особенности

В проекте приняты определённые методологии и стандарты написания кода. Важно их изучить и им следовать:

-   [CSS Code Style](codestyle-css.md)
-   [React/TS Code Style](codestyle-ts.md)

Постоянно проводятся различные RnD, находятся скрытые особенности. Если вы нашли что-то неочевидное, например поведение, отличное от стандартов и оно нигде не описано, то пожалуйста, внесите его в этот сайт.

## Проблема relayout

Есть важная особенность по перерисовке лайаута на GF. Для примера возьмем добавление нового элемента на срендеренную ранее страницу, допустим это будет черный квадрат с размерами 50x50px. Обычно, если взять движок Chromium, динамически добавив элемент мы сразу можем обратиться к нему, узнать его размеры, позицию и тд, но если сделаем это в GF, например, попытаемся узнать размер, в ответ получим `0`.

### Что за кадры и FPS

Все что мы видим на экране - это последовательность кадров, монитор обновляется, мы получаем новое изображение. Чем быстрее происходит отрисовка кадра, тем выше FPS, тем плавнее анимация, быстрее интерфейс. Золотой стандарт в анимациях - не менее 60 FPS, меньшее число даст пропуски кадров, появлятся заметные фризы анимаций, подергивания. Перерисовка страницы дорогостоящая операция, ее выполнение может занять продолжительное время, тем самым уменьшив FPS. Подробнее о том как и что влияет на перф в web при перерисовке можно прочесть, например, здесь [https://kellegous.com/j/2013/01/26/layout-performance/](https://kellegous.com/j/2013/01/26/layout-performance/)

### Так что там с GF

Дело в том, что GF не сразу делает relayout страницы, в отличии от других движков, а планирует и выполнит эту операцию на следующем кадре (в нашем случаи из-за особенностей интеграции нужно расчитывать на два кадра вперед), и именно поэтому сразу добавив элемент в дерево и попытавшись узнать его размер мы получаем 0 - элемент создан, но relayout еще не произошел, он запланирован в следующем кадре. Движок GF таким образом оптимизирует выполнение кода, пытается вложиться в каждом кадре в максимально сжатые сроки, чтобы получить максимально большой FPS.

### Как всетаки узнать размер блока

Узнать размер блока, его другие свойства, состояния, можно в следующем кадре, именно когда произойдет relayout, воспользовавшись `requestAnimationFrame` ([GF ссылка](https://docs.coherent-labs.com/cpp-gameface/api_reference/classes/interface_window/#function-requestanimationframe)). Это полезная функция, которая позволит оптимизировать анимацию путем планирования ее выполнения для каждого кардра, тем самым сократив обьем выполняемого кода в промежуток времени.

## Запуск

Для того, чтобы начать что-то делать, нужно выкачать ветку, где будет производится разработка. После того, как ветка выкачана нужно запустить клиент. exe-зешник находится по пути `game\bin\client\WorldOfTanks_h.exe`, далее клиент нужно закрыть. Делалось это все для того, чтобы сбилдилось несколько файлов, среди которых `game\bin\client\preferences.xml`.

### Использование ресурсов

В Gameface доступна возможность использования ресурсов с использованием R-class'а как в js-коде, так и в css. Здесь будет кратно описано как работать с изображениями.

Итак, допустим нужно добавить какую-то картинку на фон какого-то блока. Все изображения хранятся по пути `\game\res\wot\gui\maps`. Например изображения для глобальных компонентов хранятся здесь `\game\res\wot\gui\maps\icons\components`, а вот здесь все, что связано с компонентом кнопка `\game\res\wot\gui\maps\icons\components\button`. Чтобы что-то добавить нужно для начала определить куда положить ресурс. Допустим у нас уникальная картинка для какого-то уникального евента. Тогда создадим папку eventName в `\game\res\wot\gui\maps\icons`, должно получится `\game\res\wot\gui\maps\icons\eventName`, ну и кладем нужную картинку в данную папку. Далее, чтобы изображение стало доступно, требуется:

-   открыть файл `\game\bin\tools\wgpygen\rules\common\providers.yaml` и прописать в `all_images_fs_provider.config.include` путь к нашим картинкам `*/gui/maps/icons/eventName/*.png`
-   далее закрываем клиент, запускаем `\game\bin\tools\wgpygen\wgpygen.py`
-   после работы `wgpygen` нам будет доступен `R` класс картинки, который мы далее можем использовать, выглядит он так '`R.images.gui.maps.icons.eventName.ImageName`'
-   Используем `R` класс там, где это нужно

```css
.base {
    background-image: url('R.images.gui.maps.icons.eventName.ImageName');
}
```

Если папка с картинками уже существует и нужно их лишь туда добавить, то вносить в `providers.yaml` ничего не нужно, а просто кладем картинку в нужное место, закрываем клиент и запускаем `wgpygen.bat`. Хочется сконцентрировать внимание на перезапуске клиента, если это не будет сделано, то картинки не появятся.

!!!warning "ВАЖНО"

    Нужно помнить, что знак '`-`' в имени изображения будет автоматически заменен на '`_`' в R-class, ,было '`image-name.png`', станет '`R.images.gui.maps.icons.eventName.image_name`'

Комитить сгенерированные wgpygen-ом файлы не нужно, они сгенерируются автоматически с помощью teamcity-бота. Но автоматическая сборка ресурсов может быть настроена поразному, обычно это происходит раз в сутки, поэтому, если вы закомитили какие-то изображения и хотите чтобы они появились у всех кто работает с проектом, то нужно пересобрать проект на teamcity или сообщить колегам о неоходимости после обновления ветки запустить wgpygen и перезапустить клиент.

!!!warning "ВАЖНО"

    Нужно знать, что если имя файла картинки начинается с цифры (например, '`80x80.png`'), то после генерации wgpygen-ом к имени картинки добавляется префикс '`c_`'. Так что к картинке можно будет обратиться так; '`R.images.gui.maps.icons.eventName.c_80x80`'.

[Ресурсная система](r.md) работает не только с изображением, но и с текстами, звуками, видео и т. д.

## Errors и где они выводятся

Различные warning, error выводятся в следующих местах

-   в [dev туле](../tools/debug.md), на вкладке Console
-   в npm вотчере
-   в game.log, который находится по пути `\game\bin\client`

---

!!!question "Задание"

    1. Познакомиться с кодобазой любой вьюхи и моками
    2. Познакомиться с работой девпанели
    3. Намеренно допустить ошибку в коде и рассмотреть работу с логами и консолью.
